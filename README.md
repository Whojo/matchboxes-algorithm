Inspired by Brillant's course on "Introduction to Neural Networks"


The matchbox algorithm aims to solve the tic-tac-toe game with a Neural Networks approach.


# Algorithm
## Construction of the graph
### Generation
It is generated by an approach closed to the brute force.
Firstly, we create a matrix of the correct size (aka 19.693x19.693).

We then start with the empty board.
We generate all possible moves.
Every possible moves represent the outgoing neighbours of the current node (aka the current board).
Those outgoing neighbours are saved in the matrix.
And we continue that way recursively until every possible (and accessible) boards have been added.

By default, the graph is generated at every call.
But you can save it that way to load it on later call.
``` sh
./src/main.py -s ./resources/unweighted_nodes.dot
```

### Load nodes
To prevent the (costly) generation of the graph, you can simply load it that way.

``` sh
./src/main.py -L ./resources/unweighted_nodes.dot
```
    
## Learning process
### Define edges' weight
### Load nodes and edges

## Play

``` sh
./src/main.py -
```


# Representation of boards
+---+---+---+
|   | x | o |
+---+---+---+
| x | x | o |
+---+---+---+
|   |   |   |
+---+---+---+

This board is represented this way:
" xoxxo   "

Each case is represented by one index and its label is then put in the index at this precise index
+---+---+---+
| 1 | 2 | 3 |
+---+---+---+
| 4 | 5 | 6 |
+---+---+---+
| 7 | 8 | 9 |
+---+---+---+


## Improve:
- We do not need to represent every boards. This is due to the fact that most of them are similar at 1 rotation/ symmetrie away. This reprensents a huge difference actually. The current model has 3^9 = 19 693 nodes. And we could reduce it to 304 nodes if we represent it the correct way.

Moreover, the overcost is only made in the construction of the graph. So the changement won't be that much of a pain.

- bitboard representation (is it possible on a three states as here ?)


# Experimentation

Innitial nbr of matches


# TLDR; How to use it ?
